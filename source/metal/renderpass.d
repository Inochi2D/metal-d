/**
    MTLRenderPass

    Copyright: Copyright © 2024-2025, Kitsunebi Games EMV
    License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
    Authors:   Luna Nielsen
*/
module metal.renderpass;
import metal.pixelformat;
import metal.device;
import metal.texture;
import metal.buffer;
import metal;
import foundation;
import objc;

import core.attribute : selector, optional;

/**
    An RGBA value used for a color pixel.
*/
struct MTLClearColor {
    
    /**
        The red color channel.
    */
    double red;
    
    /**
        The green color channel.
    */
    double green;
    
    /**
        The blue color channel.
    */
    double blue;
    
    /**
        The alpha channel.
    */
    double alpha;
}

/**
    Types of actions performed for an attachment at the start of a rendering pass.
*/
enum MTLLoadAction : NSUInteger {
    
    /**
        The GPU has permission to discard the existing contents of the attachment 
        at the start of the render pass, replacing them with arbitrary data.
    */
    DontCare = 0,
    
    /**
        The GPU preserves the existing contents of the attachment at the start 
        of the render pass.
    */
    Load = 1,
    
    /**
        The GPU writes a value to every pixel in the attachment at the start 
        of the render pass.
    */
    Clear = 2,
}

/**
    Types of actions performed for an attachment at the end of a rendering pass. 
*/
enum MTLStoreAction : NSUInteger {
    
    /**
        The GPU has permission to discard the rendered contents of the attachment 
        at the end of the render pass, replacing them with arbitrary data.
    */
    DontCare = 0,
    
    /**
        The GPU stores the rendered contents to the texture.
    */
    Store = 1,
    
    /**
        The GPU resolves the multisampled data to one sample per pixel and stores 
        the data to the resolve texture, discarding the multisample data afterwards.
    */
    MultisampleResolve = 2,
    
    /**
        The GPU stores the multisample data to the multisample texture, 
        resolves the data to a sample per pixel, 
        and stores the data to the resolve texture.
    */
    StoreAndMultisampleResolve = 3,
    
    /**
        The app will specify the store action when it encodes the render pass. 
    */
    Unknown = 4,
    
    /**
        The GPU stores depth data in a sample-position–agnostic representation.
    */
    CustomSampleDepthStore = 5,
}

/**
    Options that modify a store action.
*/
enum MTLStoreActionOptions : NSUInteger {

    /**
        An option that doesn't modify the intended behavior of a store action.
    */
    None                  = 0,
    
    /**
        An option that stores data in a sample-position–agnostic representation.
    */
    CustomSamplePositions = 1 << 0,
}

/**
    A render target that serves as the output destination for pixels generated by a render pass.
*/
extern(Objective-C)
extern class MTLRenderPassAttachmentDescriptor : NSObject {
@nogc nothrow:
public:

    /**
        Returns a new instance of the receiving class.
    */
    override static MTLRenderPassAttachmentDescriptor alloc() @selector("alloc");

    /**
        Implemented by subclasses to initialize a new object (the receiver) 
        immediately after memory for it has been allocated.
    */
    override MTLRenderPassAttachmentDescriptor init() @selector("init");

    /**
        The MTLTexture object for this attachment.
    */
    @property MTLTexture texture() @selector("texture");
    @property void texture(MTLTexture) @selector("setTexture:");

    /**
        The mipmap level of the texture to be used for rendering.
        
        Default is zero.
    */
    @property NSUInteger level() @selector("level");
    @property void level(NSUInteger) @selector("setLevel:");

    /**
        The slice of the texture to be used for rendering.
        
        Default is zero.
    */
    @property NSUInteger slice() @selector("slice");
    @property void slice(NSUInteger) @selector("setSlice:");

    /**
        The depth plane of the texture to be used for rendering.
        
        Default is zero.
    */
    @property NSUInteger depthPlane() @selector("depthPlane");
    @property void depthPlane(NSUInteger) @selector("setDepthPlane:");

    /**
        The texture used for multisample resolve operations.
        Only used (and required) if the store action is set to 
        MultisampleResolve.
    */
    @property MTLTexture resolveTexture() @selector("resolveTexture");
    @property void resolveTexture(MTLTexture) @selector("setResolveTexture:");

    /**
        The mipmap level of the resolve texture to be used for 
        multisample resolve.
        
        Default is zero.
    */
    @property NSUInteger resolveLevel() @selector("resolveLevel");
    @property void resolveLevel(NSUInteger) @selector("setResolveLevel:");

    /**
        The texture slice of the resolve texture to be used for 
        multisample resolve.
        
        Default is zero.
    */
    @property NSUInteger resolveSlice() @selector("resolveSlice");
    @property void resolveSlice(NSUInteger) @selector("setResolveSlice:");

    /**
        The texture depth plane of the resolve texture to be used 
        for multisample resolve.
        
        Default is zero.
    */
    @property NSUInteger resolveDepthPlane() @selector("resolveDepthPlane");
    @property void resolveDepthPlane(NSUInteger) @selector("setResolveDepthPlane:");

    /**
        The action to be performed with this attachment at the beginning of a render pass.
        Default is DontCare unless specified by a creation or init method.
    */
    @property MTLLoadAction loadAction() @selector("loadAction");
    @property void loadAction(MTLLoadAction) @selector("setLoadAction:");

    /**
        The action to be performed with this attachment at the end of a render pass.
        Default is DontCare unless specified by a creation or init method.
    */
    @property MTLStoreAction storeAction() @selector("storeAction");
    @property void storeAction(MTLStoreAction) @selector("setStoreAction:");

    /**
        Optional configuration for the store action performed with this attachment at the end of a render pass.
        
        Default is None.
    */
    @property MTLStoreActionOptions storeActionOptions() @selector("storeActionOptions");
    @property void storeActionOptions(MTLStoreActionOptions) @selector("setStoreActionOptions:");
}

/**
    A color render target that serves as the output destination 
    for color pixels generated by a render pass.
*/
extern(Objective-C)
extern class MTLRenderPassColorAttachmentDescriptor : MTLRenderPassAttachmentDescriptor {
@nogc nothrow:
public:

    /**
        Returns a new instance of the receiving class.
    */
    override static MTLRenderPassColorAttachmentDescriptor alloc() @selector("alloc");

    /**
        Implemented by subclasses to initialize a new object (the receiver) 
        immediately after memory for it has been allocated.
    */
    override MTLRenderPassColorAttachmentDescriptor init() @selector("init");

    /**
        The clear color to be used if the loadAction property is Clear
    */
    @property MTLClearColor clearColor() @selector("clearColor");
    @property void clearColor(MTLClearColor) @selector("setClearColor:");
}

/**
    An array of render pass color attachment descriptor objects.
*/
extern(Objective-C)
extern class MTLRenderPassColorAttachmentDescriptorArray : NSObject {
@nogc nothrow:
public:

    /**
        Returns a new instance of the receiving class.
    */
    override static MTLRenderPassColorAttachmentDescriptorArray alloc() @selector("alloc");

    /**
        Implemented by subclasses to initialize a new object (the receiver) 
        immediately after memory for it has been allocated.
    */
    override MTLRenderPassColorAttachmentDescriptorArray init() @selector("init");

    /**
        Gets the MTLRenderPassColorAttachmentDescriptor at the specified index.
    */
    MTLRenderPassColorAttachmentDescriptor get(NSUInteger attachmentIndex) @selector("objectAtIndexedSubscript:");

    /*
        Sets the MTLRenderPassColorAttachmentDescriptor at the specified index.

        ### Note
        > This always uses 'copy' semantics.
        > It is safe to set the attachment state at any legal index to nil, 
        > which resets that attachment descriptor state to default values.
    */
    void set(MTLRenderPassColorAttachmentDescriptor attachment, NSUInteger attachmentIndex) @selector("setObject:atIndexedSubscript:");
}

/**
    Filtering options for controlling an MSAA depth resolve operation.
    
    Supported on iOS GPU Family 3 and later.
*/
enum MTLMultisampleDepthResolveFilter : NSUInteger {
    
    /**
        No filter is applied.
    */
    Sample0 = 0,
    
    /**
        The GPU compares all depth samples in the pixel and 
        selects the sample with the smallest value.
    */
    Min = 1,
    
    /**
        The GPU compares all depth samples in the pixel and 
        selects the sample with the largest value. 
    */
    Max = 2,
}

/**
    A depth render target that serves as the output destination 
    for depth pixels generated by a render pass.
*/
extern(Objective-C)
extern class MTLRenderPassDepthAttachmentDescriptor : MTLRenderPassAttachmentDescriptor {
@nogc nothrow:
public:

    /**
        Returns a new instance of the receiving class.
    */
    override static MTLRenderPassDepthAttachmentDescriptor alloc() @selector("alloc");

    /**
        Implemented by subclasses to initialize a new object (the receiver) 
        immediately after memory for it has been allocated.
    */
    override MTLRenderPassDepthAttachmentDescriptor init() @selector("init");

    /**
        The clear depth value to be used if the loadAction property is Clear
    */
    @property double clearDepth();
    @property void clearDepth(double);

    /**
        The filter to be used for depth multisample resolve.
        
        Defaults to Sample0.
    */
    @property MTLMultisampleDepthResolveFilter depthResolveFilter();
    @property void depthResolveFilter(MTLMultisampleDepthResolveFilter);
}

/**
    Constants used to control the multisample stencil resolve operation.
*/
enum MTLMultisampleStencilResolveFilter : NSUInteger {

    /**
        The stencil sample corresponding to sample 0. 
        
        This is the default behavior.
    */
    Sample0               = 0,

    /**
        The stencil sample corresponding to whichever depth sample is selected by the depth resolve filter. 
        If depth resolve is not enabled, the stencil sample is chosen based on what a depth resolve filter 
        would have selected.
    */
    DepthResolvedSample   = 1,
}

/**
    A stencil render target that serves as the output destination 
    for stencil pixels generated by a render pass.
*/
extern(Objective-C)
extern class MTLRenderPassStencilAttachmentDescriptor : MTLRenderPassAttachmentDescriptor {
@nogc nothrow:
public:

    /**
        Returns a new instance of the receiving class.
    */
    override static MTLRenderPassStencilAttachmentDescriptor alloc() @selector("alloc");

    /**
        Implemented by subclasses to initialize a new object (the receiver) 
        immediately after memory for it has been allocated.
    */
    override MTLRenderPassStencilAttachmentDescriptor init() @selector("init");

    /**
        The clear stencil value to be used if the loadAction property is Clear
    */
    @property uint clearDepth() @selector("clearDepth");
    @property void clearDepth(uint) @selector("setClearDepth:");

    /**
        The filter to be used for stencil multisample resolve. 
        
        Defaults to Sample0.
    */
    @property MTLMultisampleStencilResolveFilter stencilResolveFilter() @selector("stencilResolveFilter");
    @property void stencilResolveFilter(MTLMultisampleStencilResolveFilter) @selector("setStencilResolveFilter:");
}

/**
    A group of render targets that hold the results of a render pass.
*/
extern(Objective-C)
extern class MTLRenderPassDescriptor : NSObject {
@nogc nothrow:
public:

    /**
        Create an autoreleased default frame buffer descriptor
    */
    static MTLRenderPassDescriptor create() @selector("renderPassDescriptor");

    /**
        Color attachments.
    */
    @property MTLRenderPassColorAttachmentDescriptorArray colorAttachments() const @selector("colorAttachments");

    /**
        Depth attachment.
    */
    @property MTLRenderPassDepthAttachmentDescriptor depthAttachment() @selector("depthAttachment");
    @property void depthAttachment(MTLRenderPassDepthAttachmentDescriptor) @selector("setDepthAttachment:");

    /**
        Stencil attachment.
    */
    @property MTLRenderPassStencilAttachmentDescriptor stencilAttachment() @selector("stencilAttachment");
    @property void stencilAttachment(MTLRenderPassStencilAttachmentDescriptor) @selector("setStencilAttachment:");

    /**
        Buffer into which samples passing the depth and stencil tests are counted.
    */
    @property MTLBuffer visibilityResultBuffer() @selector("visibilityResultBuffer");
    @property void visibilityResultBuffer(MTLBuffer) @selector("setVisibilityResultBuffer:");

    /**
        The number of active layers.
    */
    @property NSUInteger renderTargetArrayLength() @selector("renderTargetArrayLength");
    @property void renderTargetArrayLength(NSUInteger) @selector("setRenderTargetArrayLength:");

    /**
        The per sample size in bytes of the largest explicit imageblock layout in the renderPass.
    */
    @property NSUInteger imageblockSampleLength() @selector("imageblockSampleLength");
    @property void imageblockSampleLength(NSUInteger) @selector("setImageblockSampleLength:");

    /**
        The per tile size in bytes of the persistent threadgroup memory allocation.
    */
    @property NSUInteger threadgroupMemoryLength() @selector("threadgroupMemoryLength");
    @property void threadgroupMemoryLength(NSUInteger) @selector("setThreadgroupMemoryLength:");

    /**
        The width in pixels of the tile.

        Defaults to 0.
        Zero means Metal chooses a width that fits within the local memory.
    */
    @property NSUInteger tileWidth() @selector("tileWidth");
    @property void tileWidth(NSUInteger) @selector("setTileWidth:");

    /**
        The height in pixels of the tile.

        Defaults to 0.
        Zero means Metal chooses a height that fits within the local memory.
    */
    @property NSUInteger tileHeight() @selector("tileHeight");
    @property void tileHeight(NSUInteger) @selector("setTileHeight:");

    /**
        The raster sample count for the render pass when no attachments are given.
    */
    @property NSUInteger defaultRasterSampleCount() @selector("defaultRasterSampleCount");
    @property void defaultRasterSampleCount(NSUInteger) @selector("setDefaultRasterSampleCount:");

    /**
        The width in pixels to constrain the render target to.

        Defaults to 0.
        
        If non-zero the value must be smaller than or equal to the minimum 
        width of all attachments.
    */
    @property NSUInteger renderTargetWidth() @selector("renderTargetWidth");
    @property void renderTargetWidth(NSUInteger) @selector("setRenderTargetWidth:");

    /**
        The height in pixels to constrain the render target to.

        Defaults to 0. 
        
        If non-zero the value must be smaller than or equal to the minimum 
        height of all attachments.
    */
    @property NSUInteger renderTargetHeight() @selector("renderTargetHeight");
    @property void renderTargetHeight(NSUInteger) @selector("setRenderTargetHeight:");

    /**
        Configure the custom sample positions, to be used in MSAA rendering 
        (i.e. when sample count > 1).
    */
    void tileWidthSamplePositions(const(MTLSamplePosition)* position, NSUInteger count) @selector("setSamplePositions:count:");

    /**
        Retrieve the previously configured custom sample positions. 

        The positions input array will only be modified when count specifies a length 
        sufficient for the number of previously configured positions.
    */
    NSUInteger getSamplePositions(MTLSamplePosition* position, NSUInteger count) @selector("getSamplePositions:count:");
}

/**
    Indicates whether shader validation in an enabled or disabled state, 
    or neither state.
*/
enum MTLShaderValidation : NSInteger {
    Default,
    Disabled,
    Enabled
}

/**

*/
enum MTLBlendFactor : NSUInteger {
    Zero = 0,
    One = 1,
    SourceColor = 2,
    OneMinusSourceColor = 3,
    SourceAlpha = 4,
    OneMinusSourceAlpha = 5,
    DestinationColor = 6,
    OneMinusDestinationColor = 7,
    DestinationAlpha = 8,
    OneMinusDestinationAlpha = 9,
    SourceAlphaSaturated = 10,
    BlendColor = 11,
    OneMinusBlendColor = 12,
    BlendAlpha = 13,
    OneMinusBlendAlpha = 14,
    Source1Color = 15,
    OneMinusSource1Color = 16,
    Source1Alpha = 17,
    OneMinusSource1Alpha = 18,
}

/**

*/
enum MTLBlendOperation : NSUInteger {
    Add = 0,
    Subtract = 1,
    ReverseSubtract = 2,
    Min = 3,
    Max = 4,
}

/**

*/
enum MTLColorWriteMask : NSUInteger {
    None  = 0,
    Red   = 0x1 << 3,
    Green = 0x1 << 2,
    Blue  = 0x1 << 1,
    Alpha = 0x1 << 0,
    All   = 0xf
}

/**

*/
enum MTLPrimitiveTopologyClass : NSUInteger {
    Unspecified = 0,
    Point = 1,
    Line = 2,
    Triangle = 3,
}

/**

*/
enum MTLTessellationPartitionMode : NSUInteger {
    Pow2 = 0,
    Integer = 1,
    FractionalOdd = 2,
    FractionalEven = 3,
}

/**

*/
enum MTLTessellationFactorStepFunction : NSUInteger {
    Constant = 0,
    PerPatch = 1,
    PerInstance = 2,
    PerPatchAndPerInstance = 3,
}

/**

*/
enum MTLTessellationFactorFormat : NSUInteger {
    Half = 0,
}

/**

*/
enum MTLTessellationControlPointIndexType : NSUInteger {
    None = 0,
    UInt16 = 1,
    UInt32 = 2,
}

/**
    Options for filtering texels within a mip level.   
*/
enum MTLSamplerMinMagFilter : NSUInteger
{

    /**
        Select the single texel nearest to the sample point.
    */
    Nearest = 0,

    /**
        Select two texels in each dimension, and interpolate linearly between them.
        Not all devices support linear filtering for all formats.
        Integer textures can not use linear filtering on any device, 
        and only some devices support linear filtering of float textures.
    */
    Linear = 1,
}

/**
    Options for selecting and filtering between mipmap levels
*/
enum MTLSamplerMipFilter : NSUInteger
{

    /**
        The texture is sampled as if it only had a single mipmap level.  All samples are read from level 0.
    */
    NotMipmapped = 0,

    /**
        The nearst mipmap level is selected.
    */
    Nearest = 1,

    /**
        If the filter falls between levels, both levels are sampled, 
        and their results linearly interpolated between levels.
    */
    Linear = 2,
}

/**
    Options for what value is returned when a fetch falls outside the bounds of a texture.
*/
enum MTLSamplerAddressMode : NSUInteger
{

    /**
        Texture coordinates will be clamped between 0 and 1.
    */
    ClampToEdge = 0,

    /**
        Mirror the texture while coordinates are within -1..1, and clamp to edge when outside.
    */
    MirrorClampToEdge = 1,

    /**
        Wrap to the other side of the texture, effectively ignoring fractional parts of the 
        texture coordinate.
    */
    Repeat = 2,

    /**
        Between -1 and 1 the texture is mirrored across the 0 axis.
        
        The image is repeated outside of that range.
    */
    MirrorRepeat = 3,

    /**
        ClampToZero returns transparent zero (0,0,0,0) for images with an alpha channel, 
        and returns opaque zero (0,0,0,1) for images without an alpha channel.
    */
    ClampToZero = 4,

    /**
        ClampToBorderColor returns the value specified by the borderColor variable of 
        the MTLSamplerDesc.
    */
    ClampToBorderColor = 5,
}

/**
    Specify the color value that will be clamped to when the sampler address mode is 
    ClampToBorderColor.
*/
enum MTLSamplerBorderColor : NSUInteger
{

    /**
        TransparentBlack returns {0,0,0,0} for clamped texture values.
    */
    TransparentBlack = 0,

    /**
        OpaqueBlack returns {0,0,0,1} for clamped texture values.
    */
    OpaqueBlack = 1,

    /**
        OpaqueWhite returns {1,1,1,1} for clamped texture values.
    */
    OpaqueWhite = 2,
}


/**
    A color render target that serves as the output destination 
    for color pixels generated by a render pass.
*/
extern(Objective-C)
extern class MTLRenderPipelineColorAttachmentDescriptor : MTLRenderPassAttachmentDescriptor {
@nogc nothrow:
public:

    /**
        Returns a new instance of the receiving class.
    */
    override static MTLRenderPipelineColorAttachmentDescriptor alloc() @selector("alloc");

    /**
        Implemented by subclasses to initialize a new object (the receiver) 
        immediately after memory for it has been allocated.
    */
    override MTLRenderPipelineColorAttachmentDescriptor init() @selector("init");

    /**
        
    */
    @property MTLPixelFormat pixelFormat() @selector("pixelFormat");
    @property void pixelFormat(MTLPixelFormat) @selector("setPixelFormat:");

    /**
        
    */
    @property bool blendingEnabled() @selector("isBlendingEnabled");
    @property void blendingEnabled(bool) @selector("setBlendingEnabled:");

    /**
        
    */
    @property MTLBlendFactor sourceRGBBlendFactor() @selector("sourceRGBBlendFactor");
    @property void sourceRGBBlendFactor(MTLBlendFactor) @selector("setSourceRGBBlendFactor:");

    /**
        
    */
    @property MTLBlendFactor destinationRGBBlendFactor() @selector("destinationRGBBlendFactor");
    @property void destinationRGBBlendFactor(MTLBlendFactor) @selector("setDestinationRGBBlendFactor:");

    /**
        
    */
    @property MTLBlendFactor sourceAlphaBlendFactor() @selector("sourceAlphaBlendFactor");
    @property void sourceAlphaBlendFactor(MTLBlendFactor) @selector("setSourceAlphaBlendFactor:");

    /**
        
    */
    @property MTLBlendFactor destinationAlphaBlendFactor() @selector("destinationAlphaBlendFactor");
    @property void destinationAlphaBlendFactor(MTLBlendFactor) @selector("setDestinationAlphaBlendFactor:");
}

/**
    An array of render pass color attachment descriptor objects.
*/
extern(Objective-C)
extern class MTLRenderPipelineColorAttachmentDescriptorArray : NSObject {
@nogc nothrow:
public:

    /**
        Returns a new instance of the receiving class.
    */
    override static MTLRenderPipelineColorAttachmentDescriptorArray alloc() @selector("alloc");

    /**
        Implemented by subclasses to initialize a new object (the receiver) 
        immediately after memory for it has been allocated.
    */
    override MTLRenderPipelineColorAttachmentDescriptorArray init() @selector("init");

    /**
        Gets the MTLRenderPipelineColorAttachmentDescriptor at the specified index.
    */
    MTLRenderPipelineColorAttachmentDescriptor get(NSUInteger attachmentIndex) @selector("objectAtIndexedSubscript:");

    /*
        Sets the MTLRenderPipelineColorAttachmentDescriptor at the specified index.

        ### Note
        > This always uses 'copy' semantics.
        > It is safe to set the attachment state at any legal index to nil, 
        > which resets that attachment descriptor state to default values.
    */
    void set(MTLRenderPipelineColorAttachmentDescriptor attachment, NSUInteger attachmentIndex) @selector("setObject:atIndexedSubscript:");
}

/**
    An argument of options you pass to a GPU device to get a render pipeline state.
*/
extern(Objective-C)
extern class MTLRenderPipelineDescriptor : NSObject {
@nogc nothrow:
public:

    /**
        Returns a new instance of the receiving class.
    */
    override static MTLRenderPipelineDescriptor alloc() @selector("alloc");

    /**
        Implemented by subclasses to initialize a new object (the receiver) 
        immediately after memory for it has been allocated.
    */
    override MTLRenderPipelineDescriptor init() @selector("init");

    /**
        The vertex function the pipeline calls to process vertices.
    */
    @property MTLFunction vertexFunction() @selector("vertexFunction");
    @property void vertexFunction(MTLFunction) @selector("setVertexFunction:");

    /**
        The fragment function the pipeline calls to process fragments.
    */
    @property MTLFunction fragmentFunction() @selector("fragmentFunction");
    @property void fragmentFunction(MTLFunction) @selector("setFragmentFunction:");

    /**
        Color attachments.
    */
    @property MTLRenderPipelineColorAttachmentDescriptorArray colorAttachments() const @selector("colorAttachments");

    /**
        Specifies the default rendering pipeline state values for the descriptor.
    */
    void reset() @selector("reset");
}

/**
    An interface that represents a graphics pipeline configuration for a render pass, 
    which the pass applies to the draw commands you encode.
*/
extern(Objective-C)
extern interface MTLRenderPipelineState : NSObjectProtocol {
@nogc nothrow:
public:

    /**
        The GPU device that created the command queue.
    */
    @property MTLDevice device() const;

    /**
        An optional name that can help you identify the command queue.
    */
    @property NSString label();
    @property void label(NSString);

    /**
        An unique identifier that represents the pipeline state, 
        which you can add to an argument buffer.
    */
    @property MTLResourceID gpuResourceID() const;

    /**
        The largest number of threads the pipeline state can have 
        in a single object shader threadgroup.
    */
    @property NSUInteger maxTotalThreadsPerObjectThreadgroup() const;

    /**
        The number of threads the render pass applies to a SIMD group 
        for an object shader.
    */
    @property NSUInteger objectThreadExecutionWidth() const;

    /**
        The largest number of threads the pipeline state can have 
        in a single mesh shader threadgroup.
    */
    @property NSUInteger maxTotalThreadsPerMeshThreadgroup() const;

    /**
        The largest number of threadgroups the pipeline state can 
        have in a single mesh shader grid.
    */
    @property NSUInteger maxTotalThreadgroupsPerMeshGrid() const;

    /**
        The number of threads the render pass applies to a SIMD group 
        for a mesh shader.
    */
    @property NSUInteger meshThreadExecutionWidth() const;

    /**
        The largest number of threads the pipeline state can have 
        in a single tile shader threadgroup.
    */
    @property NSUInteger maxTotalThreadsPerThreadgroup() const;

    /**
        A Boolean value that indicates whether the pipeline state 
        needs a threadgroup’s size to equal a tile’s size.
    */
    @property NSUInteger threadgroupSizeMatchesTileSize() const;

    /**
        The memory size, in byes, of the render pipeline’s imageblock 
        for a single sample.
    */
    @property NSUInteger imageblockSampleLength() const;

    /**
        A Boolean value that indicates whether the render pipeline 
        supports encoding commands into an indirect command buffer.
    */
    @property bool supportIndirectCommandBuffers() const;

    /**
        The current state of shader validation for the pipeline.
    */
    @property MTLShaderValidation shaderValidation() const;
    
    /**
        Returns the length of an imageblock’s memory for the specified
        imageblock dimensions.
    */
    @property NSUInteger imageblockMemoryLengthForDimensions(MTLSize imageblockDimensions) @selector("imageblockMemoryLengthForDimensions:");
}
