/**
    MTLRenderPipeline

    Copyright: Copyright © 2024-2025, Kitsunebi Games EMV
    License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
    Authors:   Luna Nielsen
*/
module metal.renderpipeline;
import metal.pixelformat;
import metal.library;
import metal.types;
import metal.device;
import metal.texture;
import metal.buffer;
import metal.renderpass;
import foundation;
import objc;

import core.attribute : selector, optional;

/**

*/
enum MTLBlendFactor : NSUInteger {
    Zero = 0,
    One = 1,
    SourceColor = 2,
    OneMinusSourceColor = 3,
    SourceAlpha = 4,
    OneMinusSourceAlpha = 5,
    DestinationColor = 6,
    OneMinusDestinationColor = 7,
    DestinationAlpha = 8,
    OneMinusDestinationAlpha = 9,
    SourceAlphaSaturated = 10,
    BlendColor = 11,
    OneMinusBlendColor = 12,
    BlendAlpha = 13,
    OneMinusBlendAlpha = 14,
    Source1Color = 15,
    OneMinusSource1Color = 16,
    Source1Alpha = 17,
    OneMinusSource1Alpha = 18,
}

/**

*/
enum MTLBlendOperation : NSUInteger {
    Add = 0,
    Subtract = 1,
    ReverseSubtract = 2,
    Min = 3,
    Max = 4,
}

/**

*/
enum MTLColorWriteMask : NSUInteger {
    None = 0,
    Red = 0x1 << 3,
    Green = 0x1 << 2,
    Blue = 0x1 << 1,
    Alpha = 0x1 << 0,
    All = 0xf
}

/**

*/
enum MTLPrimitiveTopologyClass : NSUInteger {
    Unspecified = 0,
    Point = 1,
    Line = 2,
    Triangle = 3,
}

/**

*/
enum MTLTessellationPartitionMode : NSUInteger {
    Pow2 = 0,
    Integer = 1,
    FractionalOdd = 2,
    FractionalEven = 3,
}

/**

*/
enum MTLTessellationFactorStepFunction : NSUInteger {
    Constant = 0,
    PerPatch = 1,
    PerInstance = 2,
    PerPatchAndPerInstance = 3,
}

/**

*/
enum MTLTessellationFactorFormat : NSUInteger {
    Half = 0,
}

/**

*/
enum MTLTessellationControlPointIndexType : NSUInteger {
    None = 0,
    UInt16 = 1,
    UInt32 = 2,
}

/**
    Options for filtering texels within a mip level.   
*/
enum MTLSamplerMinMagFilter : NSUInteger {

    /**
        Select the single texel nearest to the sample point.
    */
    Nearest = 0,

    /**
        Select two texels in each dimension, and interpolate linearly between them.
        Not all devices support linear filtering for all formats.
        Integer textures can not use linear filtering on any device, 
        and only some devices support linear filtering of float textures.
    */
    Linear = 1,
}

/**
    Options for selecting and filtering between mipmap levels
*/
enum MTLSamplerMipFilter : NSUInteger {

    /**
        The texture is sampled as if it only had a single mipmap level.  All samples are read from level 0.
    */
    NotMipmapped = 0,

    /**
        The nearst mipmap level is selected.
    */
    Nearest = 1,

    /**
        If the filter falls between levels, both levels are sampled, 
        and their results linearly interpolated between levels.
    */
    Linear = 2,
}

/**
    Options for what value is returned when a fetch falls outside the bounds of a texture.
*/
enum MTLSamplerAddressMode : NSUInteger {

    /**
        Texture coordinates will be clamped between 0 and 1.
    */
    ClampToEdge = 0,

    /**
        Mirror the texture while coordinates are within -1..1, and clamp to edge when outside.
    */
    MirrorClampToEdge = 1,

    /**
        Wrap to the other side of the texture, effectively ignoring fractional parts of the 
        texture coordinate.
    */
    Repeat = 2,

    /**
        Between -1 and 1 the texture is mirrored across the 0 axis.
        
        The image is repeated outside of that range.
    */
    MirrorRepeat = 3,

    /**
        ClampToZero returns transparent zero (0,0,0,0) for images with an alpha channel, 
        and returns opaque zero (0,0,0,1) for images without an alpha channel.
    */
    ClampToZero = 4,

    /**
        ClampToBorderColor returns the value specified by the borderColor variable of 
        the MTLSamplerDesc.
    */
    ClampToBorderColor = 5,
}

/**
    Specify the color value that will be clamped to when the sampler address mode is 
    ClampToBorderColor.
*/
enum MTLSamplerBorderColor : NSUInteger {

    /**
        TransparentBlack returns {0,0,0,0} for clamped texture values.
    */
    TransparentBlack = 0,

    /**
        OpaqueBlack returns {0,0,0,1} for clamped texture values.
    */
    OpaqueBlack = 1,

    /**
        OpaqueWhite returns {1,1,1,1} for clamped texture values.
    */
    OpaqueWhite = 2,
}

/**
    A color render target that serves as the output destination 
    for color pixels generated by a render pass.
*/
extern (Objective-C)
extern class MTLRenderPipelineColorAttachmentDescriptor : NSObject, NSCopying {
@nogc nothrow:
public:

    // copyWithZone
    override id copyWithZone(NSZone* zone) @selector("copyWithZone:") ;

    /**
        Returns a new instance of the receiving class.
    */
    override static MTLRenderPipelineColorAttachmentDescriptor alloc() @selector("alloc") ;

    /**
        Implemented by subclasses to initialize a new object (the receiver) 
        immediately after memory for it has been allocated.
    */
    override MTLRenderPipelineColorAttachmentDescriptor init() @selector("init") ;

    /**
        
    */
    @property MTLPixelFormat pixelFormat() @selector("pixelFormat") ;
    @property void pixelFormat(MTLPixelFormat) @selector("setPixelFormat:") ;

    /**
        
    */
    @property bool blendingEnabled() @selector("isBlendingEnabled") ;
    @property void blendingEnabled(bool) @selector("setBlendingEnabled:") ;

    /**
        
    */
    @property MTLBlendFactor sourceRGBBlendFactor() @selector("sourceRGBBlendFactor") ;
    @property void sourceRGBBlendFactor(MTLBlendFactor) @selector("setSourceRGBBlendFactor:") ;

    /**
        
    */
    @property MTLBlendFactor destinationRGBBlendFactor() @selector("destinationRGBBlendFactor") ;
    @property void destinationRGBBlendFactor(MTLBlendFactor) @selector(
        "setDestinationRGBBlendFactor:") ;

    /**
        
    */
    @property MTLBlendFactor sourceAlphaBlendFactor() @selector("sourceAlphaBlendFactor") ;
    @property void sourceAlphaBlendFactor(MTLBlendFactor) @selector("setSourceAlphaBlendFactor:") ;

    /**
        
    */
    @property MTLBlendFactor destinationAlphaBlendFactor() @selector("destinationAlphaBlendFactor") ;
    @property void destinationAlphaBlendFactor(MTLBlendFactor) @selector(
        "setDestinationAlphaBlendFactor:") ;
}

/**
    An array of render pass color attachment descriptor objects.
*/
extern (Objective-C)
extern class MTLRenderPipelineColorAttachmentDescriptorArray : NSObject {
@nogc nothrow:
public:

    /**
        Returns a new instance of the receiving class.
    */
    override static MTLRenderPipelineColorAttachmentDescriptorArray alloc() @selector("alloc") ;

    /**
        Implemented by subclasses to initialize a new object (the receiver) 
        immediately after memory for it has been allocated.
    */
    override MTLRenderPipelineColorAttachmentDescriptorArray init() @selector("init") ;

    /**
        Gets the MTLRenderPipelineColorAttachmentDescriptor at the specified index.
    */
    MTLRenderPipelineColorAttachmentDescriptor get(NSUInteger attachmentIndex) @selector(
        "objectAtIndexedSubscript:") ;

    /*
        Sets the MTLRenderPipelineColorAttachmentDescriptor at the specified index.

        ### Note
        > This always uses 'copy' semantics.
        > It is safe to set the attachment state at any legal index to nil, 
        > which resets that attachment descriptor state to default values.
    */
    void set(MTLRenderPipelineColorAttachmentDescriptor attachment, NSUInteger attachmentIndex) @selector(
        "setObject:atIndexedSubscript:") ;
}

/**
    An argument of options you pass to a GPU device to get a render pipeline state.
*/
extern (Objective-C)
extern class MTLRenderPipelineDescriptor : NSObject {
@nogc nothrow:
public:

    /**
        Returns a new instance of the receiving class.
    */
    override static MTLRenderPipelineDescriptor alloc() @selector("alloc") ;

    /**
        Implemented by subclasses to initialize a new object (the receiver) 
        immediately after memory for it has been allocated.
    */
    override MTLRenderPipelineDescriptor init() @selector("init") ;

    /**
        The vertex function the pipeline calls to process vertices.
    */
    @property MTLFunction vertexFunction() @selector("vertexFunction") ;
    @property void vertexFunction(MTLFunction) @selector("setVertexFunction:") ;

    /**
        The fragment function the pipeline calls to process fragments.
    */
    @property MTLFunction fragmentFunction() @selector("fragmentFunction") ;
    @property void fragmentFunction(MTLFunction) @selector("setFragmentFunction:") ;

    /**
        Color attachments.
    */
    @property MTLRenderPipelineColorAttachmentDescriptorArray colorAttachments() const @selector(
        "colorAttachments") ;

    /**
        Specifies the default rendering pipeline state values for the descriptor.
    */
    void reset() @selector("reset") ;
}

/**
    An interface that represents a graphics pipeline configuration for a render pass, 
    which the pass applies to the draw commands you encode.
*/
extern (Objective-C)
extern interface MTLRenderPipelineState : NSObjectProtocol {
@nogc nothrow:
public:

    /**
        The GPU device that created the command queue.
    */
    @property MTLDevice device() const;

    /**
        An optional name that can help you identify the command queue.
    */
    @property NSString label();
    @property void label(NSString);

    /**
        An unique identifier that represents the pipeline state, 
        which you can add to an argument buffer.
    */
    @property MTLResourceID gpuResourceID() const;

    /**
        The largest number of threads the pipeline state can have 
        in a single object shader threadgroup.
    */
    @property NSUInteger maxTotalThreadsPerObjectThreadgroup() const;

    /**
        The number of threads the render pass applies to a SIMD group 
        for an object shader.
    */
    @property NSUInteger objectThreadExecutionWidth() const;

    /**
        The largest number of threads the pipeline state can have 
        in a single mesh shader threadgroup.
    */
    @property NSUInteger maxTotalThreadsPerMeshThreadgroup() const;

    /**
        The largest number of threadgroups the pipeline state can 
        have in a single mesh shader grid.
    */
    @property NSUInteger maxTotalThreadgroupsPerMeshGrid() const;

    /**
        The number of threads the render pass applies to a SIMD group 
        for a mesh shader.
    */
    @property NSUInteger meshThreadExecutionWidth() const;

    /**
        The largest number of threads the pipeline state can have 
        in a single tile shader threadgroup.
    */
    @property NSUInteger maxTotalThreadsPerThreadgroup() const;

    /**
        A Boolean value that indicates whether the pipeline state 
        needs a threadgroup’s size to equal a tile’s size.
    */
    @property NSUInteger threadgroupSizeMatchesTileSize() const;

    /**
        The memory size, in byes, of the render pipeline’s imageblock 
        for a single sample.
    */
    @property NSUInteger imageblockSampleLength() const;

    /**
        A Boolean value that indicates whether the render pipeline 
        supports encoding commands into an indirect command buffer.
    */
    @property bool supportIndirectCommandBuffers() const;

    /**
        The current state of shader validation for the pipeline.
    */
    @property MTLShaderValidation shaderValidation() const;

    /**
        Returns the length of an imageblock’s memory for the specified
        imageblock dimensions.
    */
    @property NSUInteger imageblockMemoryLengthForDimensions(MTLSize imageblockDimensions) @selector(
        "imageblockMemoryLengthForDimensions:") ;
}
